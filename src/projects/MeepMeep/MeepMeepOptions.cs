using System;
using System.Linq;
using System.Reflection;
using System.Text;
using CommandLine;
using CommandLine.Text;
using MeepMeep.Extensions;

namespace MeepMeep
{
    /// <summary>
    /// Options constructed via command line arguments.
    /// Used to set the scene; to configure workload runners, workloads etc.
    /// </summary>
    [Serializable]
    public class MeepMeepOptions
    {
        protected const string NullOutputValue = "<null>";

        [OptionArray('n', "nodes", HelpText = "Space separated list of nodes to connect to.", DefaultValue = new[] { "http://127.0.0.1:8091/pools" })]
        public string[] Nodes { get; set; }

        [Option('b', "bucket", HelpText = "Name of the Bucket", DefaultValue = "default")]
        public string Bucket { get; set; }

        [Option('p', "bucketpassword", HelpText = "Password for the bucket.", DefaultValue = "")]
        public string BucketPassword { get; set; }

        [Option('c', "num-clients", HelpText = "Number of client sessions.", DefaultValue = 1)]
        public int NumOfClients { get; set; }

        [Option('s', "wl-size", HelpText = "The workload size. Depending on Workload, it could e.g. represent the num of documents to work with (per client session).", DefaultValue = 20000)]
        public int WorkloadSize { get; set; }

        [Option("doc-sample-path", HelpText = "Path to a file with an UTF8 JSON document, e.g used for inserts.", DefaultValue = "")]
        public string DocSamplePath { get; set; }

        [Option("doc-key-prefix", HelpText = "Used as a prefix to generated document keys.", DefaultValue = "mm")]
        public string DocKeyPrefix { get; set; }

        [Option("doc-key-seed", HelpText = "Used as a starting seed when generating document keys.", DefaultValue = 0)]
        public int DocKeySeed { get; set; }

        [Option("doc-key-range", HelpText = "The maximum range of document IDs use above doc-key-seed.", DefaultValue = 1000)]
        public int DocKeyRange { get; set; }

        [Option("clusteruser", HelpText = "Username for the cluster.", DefaultValue = "")]
        public string ClusterUsername { get; set; }

        [Option("clusterpassword", HelpText = "Password for the cluster.", DefaultValue = "")]
        public string ClusterPassword { get; set; }

        [Option("max-concurrency-level", HelpText = "Will control the maximum concurrency level used to control how many client tasks that will be executed in parallel.", DefaultValue = null)]
        public int? MaximumConcurrencyLevel { get; set; }

        [Option("threadpool-min", HelpText = "Min number of threads to be set on the underlying shared threadpool.", DefaultValue = null)]
        public int? ThreadPoolMinNumOfThreads { get; set; }

        [Option("threadpool-max", HelpText = "Max number of threads to be set on the underlying shared threadpool.", DefaultValue = null)]
        public int? ThreadPoolMaxNumOfThreads { get; set; }

        [Option('w', "warmup-ms", HelpText = "Determines how long time (ms) it takes before a work load's operation results is being seen as part of the workload.", DefaultValue = 100)]
        public int WarmupMs { get; set; }

        [Option('v', "verbose", HelpText = "Determines detail level of output generated by output writers etc.", DefaultValue = false)]
        public bool Verbose { get; set; }

        [Option('r', "mutation-percentage", HelpText = "The percentage of operations that should be mutations.", DefaultValue = 0.33)]
        public double MutationPercentage { get; set; }

        [Option("workload-type", HelpText = "The type of workload to be used.", DefaultValue = WorkloadType.MutationPercentage)]
        public WorkloadType WorkloadType { get; set; }

        [Option('t', "enable-timings", HelpText = "Time operations and output at end of workload.", DefaultValue = false)]
        public bool EnableOperationTiming { get; set; }

        [HelpOption('h', "help")]
        public string GetHelp()
        {
            var assembly = typeof(Program).Assembly;
            var description = assembly.GetAttribute<AssemblyDescriptionAttribute>();
            var copyright = assembly.GetAttribute<AssemblyCopyrightAttribute>();
            var version = assembly.GetAttribute<AssemblyFileVersionAttribute>();

            var help = new HelpText
            {
                Heading = new HeadingInfo(description.Description, "v" + version.Version),
                Copyright = copyright.Copyright,
                AdditionalNewLineAfterOption = true,
                AddDashesToOption = true
            };
            help.FormatOptionHelpText += OnHelpOnFormatOptionHelpText;
            help.AddOptions(this);

            return help;
        }

        protected virtual void OnHelpOnFormatOptionHelpText(object sender, FormatOptionHelpTextEventArgs args)
        {
            if (args.Option.DefaultValue == null)
            {
                args.Option.HelpText = args.Option.HelpText.Replace("(Default: )", "(Default: <null>)");
                return;
            }

            var arrayOption = args.Option as OptionArrayAttribute;

            if (arrayOption != null)
            {
                var defaultValue = (object[]) arrayOption.DefaultValue;
                var replace = string.Format("(Default: {0})", defaultValue.GetType().FullName);
                var with = string.Format("(Default: \"{0}\")", string.Join(" ", defaultValue.Select(o => o.ToString())));

                args.Option.HelpText = args.Option.HelpText.Replace(replace, with);
                return;
            }

            if (args.Option.DefaultValue is string)
            {
                var defaultValue = args.Option.DefaultValue.ToString();
                var replace = string.Format("(Default: {0})", defaultValue);
                var with = string.Format("(Default: \"{0}\")", defaultValue);

                args.Option.HelpText = args.Option.HelpText.Replace(replace, with);
                return;
            }
        }

        public override string ToString()
        {
            var sb = new StringBuilder();
            var props = GetOptionProperties();

            foreach (var prop in props)
            {
                var option = (BaseOptionAttribute)prop.GetCustomAttributes(false).First(IsOptionAttribute);

                sb.Append(option.LongName);
                sb.Append("=");

                var value = prop.GetValue(this, new object[0]);

                if (value == null)
                    sb.AppendLine(NullOutputValue);
                else if (value is string)
                {
                    sb.Append("\"");
                    sb.Append(value);
                    sb.AppendLine("\"");
                }
                else if (value is string[])
                {
                    sb.Append("\"");
                    sb.Append(string.Join(" ", (string[])value));
                    sb.AppendLine("\"");
                }
                else
                    sb.AppendLine(value.ToString());
            }

            return sb.ToString();
        }

        protected virtual PropertyInfo[] GetOptionProperties()
        {
            return GetType()
                .GetProperties()
                .Where(p => p.CanRead && p.GetCustomAttributes(false).Any(IsOptionAttribute))
                .ToArray();
        }

        protected virtual bool IsOptionAttribute(object attribute)
        {
            return attribute is BaseOptionAttribute;
        }
    }
}